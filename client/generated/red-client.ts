// Auto-generated by https://github.com/vladkens/apigen-ts
// Source: http://localhost:8000/api/schema/

type Headers = Record<string, string>
export type ApigenHeaders =
  | Headers
  | ((method: string, path: string) => Headers | Promise<Headers>)

export interface ApigenConfig {
  baseUrl: string
  headers: ApigenHeaders
}

export interface ApigenRequest extends Omit<RequestInit, 'body'> {
  search?: Record<string, unknown>
  body?: unknown
}

async function readableStreamToString(stream) {
  const reader = stream.getReader()
  const decoder = new TextDecoder()
  let result = ''

  while (true) {
    const { value, done } = await reader.read()

    if (value) {
      // Decode the current chunk and append to result
      result += decoder.decode(value, { stream: !done })
    }

    if (done) {
      break
    }
  }

  return result
}

export class ApiClient {
  ISO_FORMAT =
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d*)?(?:[-+]\d{2}:?\d{2}|Z)?$/
  Config: ApigenConfig

  constructor(config?: Partial<ApigenConfig>) {
    this.Config = { baseUrl: '/', headers: {}, ...config }
  }

  PopulateDates<T>(d: T): T {
    if (d === null || d === undefined || typeof d !== 'object') return d

    const t = d as unknown as Record<string, unknown>
    for (const [k, v] of Object.entries(t)) {
      if (typeof v === 'string' && this.ISO_FORMAT.test(v)) t[k] = new Date(v)
      else if (typeof v === 'object') this.PopulateDates(v)
    }

    return d
  }

  async ParseError(rep: Response) {
    console.error('inside client url', rep.url)
    console.error('inside client status', rep.status)
    console.error('inside client statusText', rep.statusText)
    const body = await readableStreamToString(rep.body)
    console.error('inside client body', body)

    try {
      return await rep.json()
    } catch (e) {
      throw rep
    }
  }

  PrepareFetchUrl(path: string): URL {
    let base = this.Config.baseUrl
    if ('location' in globalThis && (base === '' || base.startsWith('/'))) {
      const { location } = globalThis as unknown as {
        location: { origin: string }
      }
      base = `${location.origin}${base.endsWith('/') ? base : `/${base}`}`
    }

    return new URL(path, base)
  }

  async Fetch<T>(
    method: string,
    path: string,
    opts: ApigenRequest = {}
  ): Promise<T> {
    const url = this.PrepareFetchUrl(path)

    for (const [k, v] of Object.entries(opts?.search ?? {})) {
      url.searchParams.append(k, Array.isArray(v) ? v.join(',') : (v as string))
    }

    const configHeaders =
      typeof this.Config.headers === 'function' ?
        await this.Config.headers(method, path)
      : this.Config.headers

    const headers = new Headers({ ...configHeaders, ...opts.headers })
    const ct = headers.get('content-type') ?? 'application/json'

    let body: FormData | URLSearchParams | string | undefined = undefined

    if (
      ct === 'multipart/form-data' ||
      ct === 'application/x-www-form-urlencoded'
    ) {
      headers.delete('content-type')
      body =
        ct === 'multipart/form-data' ? new FormData() : new URLSearchParams()
      for (const [k, v] of Object.entries(
        opts.body as Record<string, string>
      )) {
        body.append(k, v)
      }
    }

    if (ct === 'application/json' && typeof opts.body !== 'string') {
      headers.set('content-type', 'application/json')
      body = JSON.stringify(opts.body)
    }

    const credentials = opts.credentials ?? 'include'
    const rep = await fetch(url.toString(), {
      method,
      ...opts,
      headers,
      body,
      credentials
    })
    if (!rep.ok) throw await this.ParseError(rep)

    const rs = await rep.text()
    try {
      return this.PopulateDates(JSON.parse(rs) as T)
    } catch (e) {
      return rs as unknown as T
    }
  }

  red = {
    docList: (search: {
      area?: string[]
      group?: string[]
      limit?: number
      offset?: number
      published_after?: string
      published_before?: string
      search?: string
      sort?: ('-number' | '-published' | 'number' | 'published')[]
      status?: (
        | 'bcp'
        | 'experimental'
        | 'historic'
        | 'informational'
        | 'not-issued'
        | 'standard'
        | 'unknown'
      )[]
      stream?: string[]
    }) => {
      return this.Fetch<PaginatedRfcMetadataList>('get', '/api/red/doc/', {
        search
      })
    },

    docRetrieve: (rfc_number: number) => {
      return this.Fetch<Rfc>('get', `/api/red/doc/${rfc_number}/`, {})
    }
  }

  schema = {
    retrieve: (search: { format?: 'json' | 'yaml' }) => {
      return this.Fetch<Record<string, unknown>>('get', '/api/schema/', {
        search
      })
    }
  }
}

export type ClientErrorEnum = 'client_error'

export type DocIdentifier = {
  type: DocIdentifierTypeEnum
  value: string
}

export type DocIdentifierTypeEnum = 'doi' | 'issn'

export type Error404 = {
  code: ErrorCode404Enum
  detail: string
  attr: string | null
}

export type ErrorCode404Enum = 'not_found'

export type ErrorResponse404 = {
  type: ClientErrorEnum
  errors: Error404[]
}

export type FormatsEnum = 'xml' | 'txt' | 'html' | 'htmlized' | 'pdf' | 'ps'

export type Group = {
  acronym: string
  name: string
}

export type PaginatedRfcMetadataList = {
  count: number
  next?: string | null
  previous?: string | null
  results: RfcMetadata[]
}

export type ParseError = {
  code: ParseErrorCodeEnum
  detail: string
  attr: string | null
}

export type ParseErrorCodeEnum = 'parse_error'

export type ParseErrorResponse = {
  type: ClientErrorEnum
  errors: ParseError[]
}

export type RedDocListAreaErrorComponent = {
  attr: 'area'
  code: 'invalid_choice' | 'invalid_list' | 'invalid_pk_value'
  detail: string
}

export type RedDocListError =
  | RedDocListPublishedErrorComponent
  | RedDocListStreamErrorComponent
  | RedDocListGroupErrorComponent
  | RedDocListAreaErrorComponent
  | RedDocListStatusErrorComponent
  | RedDocListSortErrorComponent

export type RedDocListErrorResponse400 =
  | RedDocListValidationError
  | ParseErrorResponse

export type RedDocListGroupErrorComponent = {
  attr: 'group'
  code: 'invalid_choice' | 'invalid_list' | 'invalid_pk_value'
  detail: string
}

export type RedDocListPublishedErrorComponent = {
  attr: 'published'
  code: 'invalid'
  detail: string
}

export type RedDocListSortErrorComponent = {
  attr: 'sort'
  code: 'invalid_choice'
  detail: string
}

export type RedDocListStatusErrorComponent = {
  attr: 'status'
  code: 'invalid_choice' | 'invalid_list'
  detail: string
}

export type RedDocListStreamErrorComponent = {
  attr: 'stream'
  code: 'invalid_choice' | 'invalid_list' | 'invalid_pk_value'
  detail: string
}

export type RedDocListValidationError = {
  type: ValidationErrorEnum
  errors: RedDocListError[]
}

export type RedDocRetrieveErrorResponse400 = ParseErrorResponse

export type RelatedDraft = {
  id?: number
  name: string
  title: string
}

export type RelatedRfc = {
  id: number
  number: number
  title: string
}

export type ReverseRelatedRfc = {
  id: number
  number: number
  title: string
}

export type Rfc = {
  number: number
  title: string
  published: string
  status: RfcStatus
  pages?: number | null
  authors: RfcAuthor[]
  group: Group
  area?: Group
  stream: StreamName
  identifiers?: DocIdentifier[]
  obsoletes?: RelatedRfc[]
  obsoleted_by?: ReverseRelatedRfc[]
  updates?: RelatedRfc[]
  updated_by?: ReverseRelatedRfc[]
  is_also?: string[]
  see_also?: string[]
  draft?: RelatedDraft
  abstract?: string
  formats: FormatsEnum[]
  keywords?: string[]
  errata?: string[]
  text: string | null
}

export type RfcAuthor = {
  person: number
  name: string
  email?: string
  affiliation?: string
  country?: string
}

export type RfcMetadata = {
  number: number
  title: string
  published: string
  status: RfcStatus
  pages?: number | null
  authors: RfcAuthor[]
  group: Group
  area?: Group
  stream: StreamName
  identifiers?: DocIdentifier[]
  obsoletes?: RelatedRfc[]
  obsoleted_by?: ReverseRelatedRfc[]
  updates?: RelatedRfc[]
  updated_by?: ReverseRelatedRfc[]
  is_also?: string[]
  see_also?: string[]
  draft?: RelatedDraft
  abstract?: string
  formats: FormatsEnum[]
  keywords?: string[]
  errata?: string[]
}

export type RfcStatus = {
  slug: SlugEnum
  name: string
}

export type SchemaRetrieveErrorResponse400 = ParseErrorResponse

export type SlugEnum =
  | 'bcp'
  | 'experimental'
  | 'historic'
  | 'informational'
  | 'not-issued'
  | 'standard'
  | 'unknown'

export type StreamName = {
  slug: string
  name: string
  desc?: string
}

export type ValidationErrorEnum = 'validation_error'
